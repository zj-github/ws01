package cn.innohub.crawler.firstlevel.seeds.extract;

import java.net.URL;
import java.util.Comparator;
import java.util.Date;
import java.util.List;
import java.util.Set;
import java.util.TreeSet;
import java.util.concurrent.CopyOnWriteArrayList;

import org.apache.log4j.Logger;

import cn.innohub.crawler.beans.DetailPageSeed;
import cn.innohub.crawler.beans.FirstLevelSeed;
import cn.innohub.crawler.common.InitParamsConstant;
import cn.innohub.crawler.conf.Configuration;
import cn.innohub.crawler.core.Context;
import cn.innohub.crawler.core.QueueManager;
import cn.innohub.crawler.core.ThreadLockController;
import cn.innohub.crawler.fetch.FetchTask;
import cn.innohub.crawler.packageapi.SafeTreeSet;
import cn.innohub.crawler.utils.ParseUtil;
import cn.innohub.crawler.utils.PhantomjsUtil;

/**
 * @ClassName: FisrtLevelSeedWorkShop
 * @Description: 启动抓取算法
 * @author zhangjie
 * @date 2016年1月6日 上午9:20:21
 *
 */
public class FisrtLevelSeedWorkShop implements Runnable {

	@Override
	public void run() {
		System.out.println("FisrtLevelSeedWorkShop run");
		work();
	}

	/**
	 * while(){ 1、获取nearly url u1。 2、抓取u1
	 * 3、设置u1的下次抓取时间（u1.setNextFetchTime(now+u.interval)） 4、集合排序 5、获取nearly url
	 * u2。 6、算出休眠时间 t1= Set.getFirst.getNextFetchTime() 7、sleep(t1) }
	 * 
	 * @Description: (这里用一句话描述这个方法的作用)
	 * @author zhangjie
	 * @date 2016年1月5日 下午3:42:55
	 * @param args
	 *
	 */
	private SafeTreeSet seeds = Context.getInstance().getFirstLevelSeeds();
	private boolean stop = false;
	private Logger logger = Logger.getLogger(FisrtLevelSeedWorkShop.class);

	public void work() {
		while (!stop) {
			while (seeds.size() == 0) {// 没有种子以后线程等待
				logger.debug("no seed in first leve seed set collection," + Thread.currentThread().getName()
						+ " will await until queue feed");
				long currentTimeMillis = System.currentTimeMillis();
				Long long1 = FetchTask.tl.get();
				logger.debug("thread has run " + (currentTimeMillis - long1) + " m ");
				// fetchCondition.await();
				ThreadLockController.getInstance().awaitFirstLevelSeedExtractThread();
			}
			iterator();
		}
	}

	private void iterator() {
		// * 1、弹出nearly url u1。
		// * 2、抓取u1
		// * 3、设置u1的下次抓取时间（u1.setNextFetchTime(now+u.interval)）
		// * 4、集合排序
		// * 5、获取nearly url u2。
		// * 6、算出休眠时间 t1= Set.getFirst.getNextFetchTime()
		// * 7、sleep(t1)
		// 1
		// FirstLevelSeed cur = seeds.pollFirst();
		CopyOnWriteArrayList<FirstLevelSeed> outTimeSeed = getOutTimeSeed();

		// 2、3、
		this.fetchAndExtract(outTimeSeed);
		
		// 4、
		seeds.addAll(outTimeSeed);// 会从新排序
		// 5、
		FirstLevelSeed first = seeds.first();
		try {
			// 6、休眠时间：下次抓取时间最近的种子的下次抓取时间-到现在的时间
			long sleepInterval = first.getNextFetchTime().getTime() - new Date().getTime();
			// 7、
			Thread.sleep(sleepInterval);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
	}

	/**
	 * 
	 * @Description: 抓取一级种子，抽取外链，加入详情页种子队列
	 * @author zhangjie
	 * @date 2016年1月6日 上午11:33:56
	 * @param outTimeSeed
	 *
	 */
	public void fetchAndExtract(List<FirstLevelSeed> outTimeSeed) {
		for (FirstLevelSeed seed : outTimeSeed) {
			
//			String htmlContent = HttpClientFetcher.fetchHtmlContent(seed.getUrl());
			logger.info("PhantomjsUtil running");
			String htmlContent =PhantomjsUtil.fetchHtmlContent(seed.getUrl());
			logger.info("PhantomjsUtil over");
			List<URL> outLinks = ParseUtil.getOutLinks(seed.getUrl(), htmlContent, seed.getDetailPageReg());// 抽取外链
			logger.info("get outlinks "+outLinks.size());
			Set<DetailPageSeed> urlSet = new TreeSet<>(new SeedComparator());
			
			for (URL url : outLinks) {// 加入队列
				String clazz = (String) Configuration.getParams(url.getHost());
				urlSet.add(new DetailPageSeed(url.toString(), clazz));
			}
			QueueManager.addSeeds(urlSet);
			
			ThreadLockController.getInstance().signalFetchThread();//通知抓取线程
			this.setNextFetchTime(seed);// 抓取完成后设置下次抓取时间
		}

	}
	 class SeedComparator implements Comparator<DetailPageSeed> {
			@Override
			public int compare(DetailPageSeed o1, DetailPageSeed o2) {
				String u = o1.getUrl();
				String u2 = o2.getUrl();
				return u.compareTo(u2);
			}

		}
	private void setNextFetchTime(FirstLevelSeed cur) {
		long updateFrequency = cur.getUpdateFrequency();
		long interval = Context.getInstance().getLongParams(InitParamsConstant.DEFAULT_INTERVAL);// 默认的抓取间隔
		interval = updateFrequency == 0 ? interval : updateFrequency;
		Date nextFetchTime = new Date(new Date().getTime() + interval);
		cur.setNextFetchTime(nextFetchTime);
	}

	/**
	 * 
	 * @Description:获取 待抓取时间早于当前时间的种子
	 * @author zhangjie
	 * @date 2016年1月6日 上午10:29:14
	 *
	 */
	private CopyOnWriteArrayList<FirstLevelSeed> getOutTimeSeed() {
		return seeds.removeOutTimeSeed(new Date());
	}

}
